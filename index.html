<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>InfinitePay Splash Preview</title>
  <!-- Rive Runtime - WebGL2 -->
  <script src="https://unpkg.com/@rive-app/webgl2@latest"></script>
  <style>
    @font-face {
      font-family: 'CeraPro';
      src: url('assets/fonts/CeraPro-Regular.otf') format('opentype');
      font-weight: 400;
    }
    @font-face {
      font-family: 'CeraPro';
      src: url('assets/fonts/CeraPro-Medium.otf') format('opentype');
      font-weight: 500;
    }
    @font-face {
      font-family: 'CeraPro';
      src: url('assets/fonts/CeraPro-Bold.otf') format('opentype');
      font-weight: 700;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'CeraPro', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1a1a1a;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    /* Phone Frame Container (Desktop only) */
    .phone-frame {
      position: relative;
      width: 393px;
      height: 852px;
      background: #000;
      border-radius: 48px;
      box-shadow: 
        0 0 0 12px #2a2a2a,
        0 0 0 14px #3a3a3a,
        0 20px 60px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    /* Dynamic Island */
    .phone-frame::before {
      content: '';
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      width: 126px;
      height: 36px;
      background: #000;
      border-radius: 20px;
      z-index: 1000;
    }

    /* Screen content wrapper */
    .screen-content {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    /* Splash content */
    .splash-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.5s ease, transform 0.5s ease;
      z-index: 1;
      position: relative;
    }

    .splash-container.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .splash-container.hidden {
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
    }

    .icon-container {
      width: 120px;
      height: 120px;
      margin-bottom: 24px;
    }

    .icon-container img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .splash-text {
      color: #fff;
      font-size: 18px;
      font-weight: 500;
      line-height: 1.4;
      max-width: 260px;
      padding: 0 20px;
    }

    /* Rive container - fills phone screen */
    #rive-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      display: none;
    }

    #rive-container.visible {
      display: block;
    }

    #rive-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Settings button - OUTSIDE phone frame with protection */
    .settings-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      width: 44px;
      height: 44px;
      border-radius: 12px;
      font-size: 20px;
      cursor: pointer;
      z-index: 9999;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    .settings-toggle:hover {
      background: rgba(0, 0, 0, 0.95);
      border-color: rgba(255, 255, 255, 0.5);
      transform: scale(1.05);
    }

    /* Reload button - OUTSIDE phone frame with protection */
    .reload-btn {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 14px 28px;
      border-radius: 12px;
      font-family: 'CeraPro', sans-serif;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    .reload-btn:hover {
      background: rgba(0, 0, 0, 0.95);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateX(-50%) scale(1.02);
    }

    /* Product indicator - OUTSIDE phone frame with protection */
    .product-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.8);
      padding: 10px 20px;
      border-radius: 24px;
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    /* Status indicator - OUTSIDE phone frame */
    .status {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 11px;
      z-index: 9999;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 12px;
      border-radius: 6px;
    }

    /* Settings panel with strong protection */
    .settings-panel {
      position: fixed;
      top: 74px;
      right: 20px;
      background: rgba(15, 15, 15, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 20px;
      z-index: 9999;
      min-width: 300px;
      max-height: calc(100vh - 100px);
      overflow-y: auto;
      display: none;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(20px);
    }

    .settings-panel.visible {
      display: block;
    }

    .settings-panel h3 {
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .setting-group {
      margin-bottom: 16px;
    }

    .setting-group label {
      display: block;
      color: rgba(255, 255, 255, 0.6);
      font-size: 12px;
      margin-bottom: 8px;
    }

    .setting-group input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
    }

    .setting-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #00D26A;
      border-radius: 50%;
      cursor: pointer;
    }

    .setting-value {
      color: #00D26A;
      font-size: 14px;
      font-weight: 600;
      margin-top: 4px;
    }

    .preset-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .preset-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .preset-btn.active {
      background: #00D26A;
      border-color: #00D26A;
      color: #000;
    }

    .divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 16px 0;
    }

    /* Toggle switch for low rez */
    .toggle-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .toggle-switch {
      position: relative;
      width: 48px;
      height: 26px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 13px;
      cursor: pointer;
      transition: background 0.3s;
      flex-shrink: 0;
    }

    .toggle-switch.active {
      background: #00D26A;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle-switch.active::after {
      transform: translateX(22px);
    }

    .toggle-label {
      color: rgba(255, 255, 255, 0.8);
      font-size: 13px;
    }

    /* Mobile styles */
    @media (max-width: 500px) {
      body {
        background: #000;
      }

      .phone-frame {
        width: 100vw;
        height: 100vh;
        border-radius: 0;
        box-shadow: none;
      }

      .phone-frame::before {
        display: none;
      }

      .settings-toggle {
        top: env(safe-area-inset-top, 10px);
        right: 10px;
      }

      .product-indicator {
        top: env(safe-area-inset-top, 10px);
      }

      .reload-btn {
        bottom: calc(env(safe-area-inset-bottom, 10px) + 20px);
      }

      .status {
        bottom: calc(env(safe-area-inset-bottom, 10px) + 70px);
      }

      .settings-panel {
        top: 64px;
        right: 10px;
        left: 10px;
        min-width: auto;
        max-height: calc(100vh - 140px);
      }
    }
  </style>
</head>
<body>
  <!-- UI Controls (outside phone frame) -->
  <div class="product-indicator" id="productIndicator">Carregando...</div>
  <div class="status" id="status">Inicializando...</div>

  <!-- Settings Toggle -->
  <button class="settings-toggle" id="settingsToggle" onclick="toggleSettings()">‚öô</button>
  
  <!-- Settings Panel -->
  <div class="settings-panel" id="settingsPanel">
    <h3>‚öô Configura√ß√µes</h3>
    
    <!-- Low Rez Toggle -->
    <div class="setting-group">
      <div class="toggle-container">
        <span class="toggle-label">Usar assets Low Rez</span>
        <div class="toggle-switch" id="lowRezToggle" onclick="toggleLowRez()"></div>
      </div>
    </div>

    <div class="divider"></div>
    
    <div class="setting-group">
      <label>Tamanho do √çcone</label>
      <input type="range" id="iconSizeSlider" min="60" max="200" value="120" oninput="updateIconSize(this.value)">
      <div class="setting-value"><span id="iconSizeValue">120</span>px</div>
    </div>
    
    <div class="setting-group">
      <label>Presets</label>
      <div class="preset-buttons">
        <button class="preset-btn" onclick="setIconSize(80)">Pequeno (80)</button>
        <button class="preset-btn active" onclick="setIconSize(120)">M√©dio (120)</button>
        <button class="preset-btn" onclick="setIconSize(160)">Grande (160)</button>
      </div>
    </div>

    <div class="divider"></div>

    <div class="setting-group">
      <label>Tempo de Leitura (ms)</label>
      <input type="range" id="readingTimeSlider" min="1500" max="5000" value="2500" step="100" oninput="updateReadingTime(this.value)">
      <div class="setting-value"><span id="readingTimeValue">2500</span>ms</div>
    </div>

    <div class="setting-group">
      <label>Tempo de Loading (ms)</label>
      <input type="range" id="loadingTimeSlider" min="1000" max="5000" value="3000" step="100" oninput="updateLoadingTime(this.value)">
      <div class="setting-value"><span id="loadingTimeValue">3000</span>ms</div>
    </div>

    <div class="divider"></div>

    <div class="setting-group">
      <label>Escolher Produto</label>
      <div class="preset-buttons">
        <button class="preset-btn" onclick="selectProduct('pix')">PIX</button>
        <button class="preset-btn" onclick="selectProduct('link')">Link</button>
        <button class="preset-btn" onclick="selectProduct('loja')">Loja</button>
        <button class="preset-btn" onclick="selectProduct('random')">üé≤ Random</button>
      </div>
    </div>
  </div>

  <!-- Phone Frame (iPhone 14 Pro size) -->
  <div class="phone-frame" id="phoneFrame">
    <div class="screen-content">
      <!-- Splash Container -->
      <div class="splash-container" id="splashContainer">
        <div class="icon-container">
          <img id="iconFrame" src="" alt="Product Icon">
        </div>
        <p class="splash-text" id="splashText"></p>
      </div>

      <!-- Rive canvas (inside phone screen) -->
      <div id="rive-container">
        <canvas id="rive-canvas"></canvas>
      </div>
    </div>
  </div>

  <button class="reload-btn" onclick="location.reload()">
    ‚Üª Sortear novamente
  </button>

  <script>
    // Product configuration
    const products = [
      {
        id: 'pix',
        text: 'Receba via Pix na hora',
        frameCount: 63,
        framePattern: 'OFF83_badge_pix_ANIMATION_HM_001_XXXX.webp'
      },
      {
        id: 'link',
        text: 'Crie links de pagamento em segundos',
        frameCount: 53,
        framePattern: 'OFF83_Link_ANIMATION_HM_001_XXXX.webp'
      },
      {
        id: 'loja',
        text: 'Sua loja online pronta pra vender',
        frameCount: 60,
        framePattern: 'OFF83_loja_online_ANIMATION_HM_001_XXXX.webp'
      }
    ];

    // State
    let currentFrame = 0;
    let animationId = null;
    let selectedProduct = null;
    let riveInstance = null;
    let playFixInput = null;
    let riveReady = false;
    const FPS = 60;
    const FRAME_DURATION = 1000 / FPS;

    // Frame cache - stores preloaded Image objects
    let frameCache = [];

    // Settings state
    let iconSize = 120;
    let customReadingTime = null;
    let loadingTime = 3000;
    let forcedProduct = null;
    let useLowRez = false;

    // Get the assets path based on low rez setting
    function getAssetsPath() {
      return useLowRez ? 'assets/products_low_rez' : 'assets/products';
    }

    // Settings functions
    function toggleSettings() {
      const panel = document.getElementById('settingsPanel');
      panel.classList.toggle('visible');
    }

    function toggleLowRez() {
      useLowRez = !useLowRez;
      const toggle = document.getElementById('lowRezToggle');
      toggle.classList.toggle('active', useLowRez);
      localStorage.setItem('useLowRez', useLowRez);
      location.reload();
    }

    function updateIconSize(size) {
      iconSize = parseInt(size);
      document.getElementById('iconSizeValue').textContent = size;
      localStorage.setItem('iconSize', size);
      
      const iconContainer = document.querySelector('.icon-container');
      iconContainer.style.width = size + 'px';
      iconContainer.style.height = size + 'px';
      
      // Update preset buttons
      document.querySelectorAll('.setting-group:first-of-type .preset-btn').forEach(btn => {
        btn.classList.remove('active');
      });
    }

    function setIconSize(size) {
      document.getElementById('iconSizeSlider').value = size;
      updateIconSize(size);
      
      // Update preset buttons
      document.querySelectorAll('.setting-group:nth-of-type(4) .preset-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.includes(size)) {
          btn.classList.add('active');
        }
      });
    }

    function updateReadingTime(time) {
      customReadingTime = parseInt(time);
      document.getElementById('readingTimeValue').textContent = time;
      localStorage.setItem('customReadingTime', time);
    }

    function updateLoadingTime(time) {
      loadingTime = parseInt(time);
      document.getElementById('loadingTimeValue').textContent = time;
      localStorage.setItem('loadingTime', time);
    }

    function selectProduct(productId) {
      localStorage.setItem('forcedProduct', productId);
      location.reload();
    }

    // Get reading time (custom or calculated)
    function getReadingTime(text) {
      const savedTime = localStorage.getItem('customReadingTime');
      if (savedTime) return parseInt(savedTime);
      return calculateReadingTime(text);
    }

    // Get loading time from localStorage
    function getLoadingTime() {
      const savedTime = localStorage.getItem('loadingTime');
      return savedTime ? parseInt(savedTime) : 3000;
    }

    // Get icon size from localStorage
    function getIconSize() {
      const savedSize = localStorage.getItem('iconSize');
      return savedSize ? parseInt(savedSize) : 120;
    }

    // Status update
    function setStatus(text) {
      document.getElementById('status').textContent = text;
      console.log('Status:', text);
    }

    // Select random product (or forced product from settings)
    function selectRandomProduct() {
      const savedProduct = localStorage.getItem('forcedProduct');
      if (savedProduct && savedProduct !== 'random') {
        const product = products.find(p => p.id === savedProduct);
        if (product) return product;
      }
      const index = Math.floor(Math.random() * products.length);
      return products[index];
    }

    // Generate frame path
    function getFramePath(product, frameNumber) {
      const paddedNumber = String(frameNumber).padStart(4, '0');
      const fileName = product.framePattern.replace('XXXX', paddedNumber);
      return `${getAssetsPath()}/${product.id}/${fileName}`;
    }

    // Preload frames with caching and async decode
    async function preloadFrames(product) {
      frameCache = new Array(product.frameCount);
      const startTime = performance.now();
      
      // Load first frame immediately for instant display
      const firstImg = new Image();
      firstImg.src = getFramePath(product, 1);
      await new Promise(resolve => {
        firstImg.onload = resolve;
        firstImg.onerror = resolve;
      });
      
      // Decode first frame if supported
      if (firstImg.decode) {
        try { await firstImg.decode(); } catch(e) {}
      }
      frameCache[0] = firstImg;
      
      // Load remaining frames in parallel batches for better performance
      const BATCH_SIZE = 10;
      for (let batch = 0; batch < Math.ceil((product.frameCount - 1) / BATCH_SIZE); batch++) {
        const batchPromises = [];
        const startIdx = batch * BATCH_SIZE + 2; // Start from frame 2
        const endIdx = Math.min(startIdx + BATCH_SIZE, product.frameCount + 1);
        
        for (let i = startIdx; i < endIdx; i++) {
          const img = new Image();
          const frameIdx = i - 1; // 0-indexed cache
          
          const loadPromise = new Promise(async (resolve) => {
            img.onload = async () => {
              // Async decode for smoother playback
              if (img.decode) {
                try { await img.decode(); } catch(e) {}
              }
              frameCache[frameIdx] = img;
              resolve();
            };
            img.onerror = resolve;
            img.src = getFramePath(product, i);
          });
          
          batchPromises.push(loadPromise);
        }
        
        await Promise.all(batchPromises);
      }
      
      const loadTime = (performance.now() - startTime).toFixed(0);
      console.log(`‚úÖ Frames loaded in ${loadTime}ms`);
    }

    // Play icon animation using cached frames
    function playAnimation(product) {
      const iconFrame = document.getElementById('iconFrame');
      let lastTime = 0;
      
      function animate(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const elapsed = timestamp - lastTime;
        
        if (elapsed >= FRAME_DURATION) {
          currentFrame++;
          if (currentFrame <= product.frameCount) {
            // Use cached frame if available
            const cachedImg = frameCache[currentFrame - 1];
            if (cachedImg && cachedImg.complete) {
              iconFrame.src = cachedImg.src;
            } else {
              // Fallback to path (shouldn't happen if preload worked)
              iconFrame.src = getFramePath(product, currentFrame);
            }
            lastTime = timestamp;
          } else {
            return; // Stay on last frame
          }
        }
        
        animationId = requestAnimationFrame(animate);
      }
      
      currentFrame = 1;
      // Use cached first frame
      if (frameCache[0]) {
        iconFrame.src = frameCache[0].src;
      } else {
        iconFrame.src = getFramePath(product, 1);
      }
      animationId = requestAnimationFrame(animate);
    }

    // Initialize Rive
    async function initRive() {
      return new Promise((resolve) => {
        const canvas = document.getElementById('rive-canvas');
        const container = document.getElementById('rive-container');
        
        // Get phone frame dimensions
        const phoneFrame = document.getElementById('phoneFrame');
        const rect = phoneFrame.getBoundingClientRect();
        
        // Set canvas size to match phone screen
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        
        try {
          riveInstance = new rive.Rive({
            src: 'assets/rive/ip_app_intro.riv',
            canvas: canvas,
            autoplay: true,
            stateMachines: 'State Machine 1',
            fit: rive.Fit.Cover,
            alignment: rive.Alignment.Center,
            onLoad: () => {
              console.log('Rive loaded!');
              riveInstance.resizeDrawingSurfaceToCanvas();
              
              const inputs = riveInstance.stateMachineInputs('State Machine 1');
              console.log('Rive inputs:', inputs);
              
              if (inputs) {
                playFixInput = inputs.find(i => i.name === 'play_fix');
                console.log('play_fix input:', playFixInput);
              }
              
              riveReady = true;
              resolve();
            },
            onLoadError: (err) => {
              console.error('Rive load error:', err);
              resolve();
            },
            onStateChange: (event) => {
              console.log('Rive state:', event.data);
            }
          });
        } catch (error) {
          console.error('Rive init error:', error);
          resolve();
        }
      });
    }

    // Show Rive and trigger ENTER (1st click)
    function triggerRiveEnter() {
      const riveContainer = document.getElementById('rive-container');
      const splashContainer = document.getElementById('splashContainer');
      
      setStatus('Rive Enter...');
      
      // Hide splash immediately
      splashContainer.classList.add('hidden');
      
      // Fire trigger BEFORE showing (so animation is ready)
      if (playFixInput) {
        playFixInput.fire();
        console.log('üöÄ Fired play_fix (ENTER)');
      }
      
      // Show Rive container instantly
      riveContainer.classList.add('visible');
    }

    // Trigger EXIT (2nd click)
    function triggerRiveExit() {
      setStatus('Rive Exit...');
      
      if (playFixInput) {
        playFixInput.fire();
        console.log('üöÄ Fired play_fix (EXIT)');
      }
    }

    // Calculate reading time (2.5s - 4s)
    function calculateReadingTime(text) {
      const words = text.split(' ').length;
      const wpm = 150;
      const seconds = Math.min(Math.max((words / wpm) * 60, 2.5), 4.0);
      return seconds * 1000;
    }

    // Handle resize
    function handleResize() {
      const canvas = document.getElementById('rive-canvas');
      const phoneFrame = document.getElementById('phoneFrame');
      const rect = phoneFrame.getBoundingClientRect();
      
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      
      if (riveInstance) {
        riveInstance.resizeDrawingSurfaceToCanvas();
      }
    }

    // Load saved settings
    function loadSettings() {
      // Low rez toggle
      useLowRez = localStorage.getItem('useLowRez') === 'true';
      const lowRezToggle = document.getElementById('lowRezToggle');
      lowRezToggle.classList.toggle('active', useLowRez);
      
      // Icon size
      iconSize = getIconSize();
      document.getElementById('iconSizeSlider').value = iconSize;
      document.getElementById('iconSizeValue').textContent = iconSize;
      
      const iconContainer = document.querySelector('.icon-container');
      iconContainer.style.width = iconSize + 'px';
      iconContainer.style.height = iconSize + 'px';
      
      // Reading time
      const savedReadingTime = localStorage.getItem('customReadingTime');
      if (savedReadingTime) {
        customReadingTime = parseInt(savedReadingTime);
        document.getElementById('readingTimeSlider').value = customReadingTime;
        document.getElementById('readingTimeValue').textContent = customReadingTime;
      }
      
      // Loading time
      loadingTime = getLoadingTime();
      document.getElementById('loadingTimeSlider').value = loadingTime;
      document.getElementById('loadingTimeValue').textContent = loadingTime;
    }

    // Initialize splash
    async function initSplash() {
      const container = document.getElementById('splashContainer');
      const textElement = document.getElementById('splashText');
      const indicator = document.getElementById('productIndicator');
      const iconFrame = document.getElementById('iconFrame');
      
      // Load saved settings first
      loadSettings();
      
      // Select product early so we can start loading
      selectedProduct = selectRandomProduct();
      indicator.textContent = selectedProduct.id.toUpperCase() + (useLowRez ? ' (LOW REZ)' : '');
      textElement.textContent = selectedProduct.text;
      
      setStatus('Carregando...');
      
      // Load first frame immediately for instant visual
      const firstFramePath = getFramePath(selectedProduct, 1);
      iconFrame.src = firstFramePath;
      
      // Start loading Rive and remaining frames in PARALLEL
      const [riveResult] = await Promise.all([
        initRive(),
        preloadFrames(selectedProduct)
      ]);
      
      setStatus('Exibindo splash...');
      
      // Show container (first frame already visible)
      container.classList.add('visible');
      
      // Play icon animation (frames already cached)
      playAnimation(selectedProduct);
      
      // After reading time, trigger Rive ENTER
      const readingTime = customReadingTime || calculateReadingTime(selectedProduct.text);
      console.log(`Reading time: ${readingTime}ms`);
      
      setTimeout(() => {
        triggerRiveEnter();
        
        // Simulate "loading complete", then trigger EXIT
        setTimeout(() => {
          triggerRiveExit();
          
          // After exit animation, show "complete" status
          setTimeout(() => {
            setStatus('Splash completo!');
          }, 1500);
        }, loadingTime);
        
      }, readingTime);
    }

    // Event listeners
    window.addEventListener('load', initSplash);
    window.addEventListener('resize', handleResize);
  </script>
</body>
</html>
